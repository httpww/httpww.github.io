{"meta":{"title":"Fly","subtitle":"Let Ideas Fly","description":"��̫���ˣ�������ģ��NTT������","author":"TheT","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2019-03-24T11:57:37.000Z","updated":"2019-03-25T09:49:34.124Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"其实我是一只蒟蒻，都初二了连去省选的机会都没有，是因为我身在浙江吗？不过估计如果我参加了也只不过是听两天只听得懂中文的课，做两天只看得懂中文的题罢了。不过机房里还是有一些大佬的，比如五次AK浙江省选、三次AK IOI却在 团队 里自称菜鸟的Confident Rafflesia（逃。 作者逃了，不写下去了。 作者换了个地方继续黑我敬爱的大佬们：我们班一名大佬为逃避月考去宁波听中文去了。啊，被发现了（逃 作者被大佬们抓住后的惨状:"}],"posts":[{"title":"目录","slug":"目录","date":"2222-02-22T14:22:22.000Z","updated":"2019-03-25T09:28:23.179Z","comments":true,"path":"2222/02/22/目录/","link":"","permalink":"http://yoursite.com/2222/02/22/目录/","excerpt":"","text":"杂感 浅析卷积 数据结构线段树 区间线段树 权值线段树&amp;&amp;主席树","categories":[],"tags":[],"keywords":[]},{"title":"漫步数据结构2：线段树2","slug":"漫步数据结构2：线段树2","date":"2019-03-25T09:23:00.000Z","updated":"2019-04-01T09:57:11.558Z","comments":true,"path":"2019/03/25/漫步数据结构2：线段树2/","link":"","permalink":"http://yoursite.com/2019/03/25/漫步数据结构2：线段树2/","excerpt":"","text":"2. 权值线段树区间线段树中$[x,x]$所对应的节点指原数组中$x$号节点的值，而权值线段树中$[x,x]$所对应的节点指原数组中等于$x$的元素的个数。一般情况下，权值线段树的非叶子节点记录和。 在权值线段树上可以进行二分，以此查找整个区间内第 $ k $ 大的节点，方法简单，略过。 3. 动态开点线段树当一棵线段树中只需访问没几个节点时，我们不再默认节点 $ x $ 的左儿子是 $ 2x $ ，右儿子是 $ 2x+1 $ ，而是对每个节点分别存储左儿子和右儿子。 4.可持久化线段树（主席树）假设我们已经有了一棵线段树，现在我们需要更改一个节点的权值但还想保留原来的数据。这时我们似乎只能复制一遍了，但细观下图我们发现只改了 $ lg\\text{ }n $ 个节点。 所以我们实际上可以这样存： 那么一次修改只需新建$lg\\text{ }n$个节点就可以了。这就是可持久化线段树，非常简单。 如果这是一棵权值线段树，然后依次插入 $ n $ 个元素，取第 $ r $ 棵树和第 $ l-1 $ 棵树相减即可得出区间 $ l-r $ 的权值线段树，二分即可ACP3834 Tips: 初始的空树可以是一个标号为 $ 0 $ 的节点，它的左儿子是 $ 0 $ ，右儿子也是 $ 0 $ ，权值还是 $ 0 $ 。这样就 $ O(1) $ 建出了一棵 $ \\infty $ 的树。 于是就可以给出代码了: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int Array_Limit=200005;int N,M,m,a[Array_Limit&lt;&lt;5],d[Array_Limit&lt;&lt;5],root[Array_Limit&lt;&lt;5],record[Array_Limit&lt;&lt;5],ch[Array_Limit&lt;&lt;5][2],nodenum;void add(int l,int r,int from,int to,int data)&#123; if(l==r)&#123; record[to]=record[from]+1; return; &#125; int mid=(l+r)&gt;&gt;1; if(data&lt;=mid)&#123; ch[to][0]=++nodenum; ch[to][1]=ch[from][1]; add(l,mid,ch[from][0],ch[to][0],data); &#125; else&#123; ch[to][1]=++nodenum; ch[to][0]=ch[from][0]; add(mid+1,r,ch[from][1],ch[to][1],data); &#125; record[to]=record[ch[to][0]]+record[ch[to][1]];&#125;int find(int l,int r,int x,int y,int k)&#123; if(l==r) return l; int mid=(l+r)&gt;&gt;1; if(record[ch[y][0]]-record[ch[x][0]]&gt;=k) return find(l,mid,ch[x][0],ch[y][0],k); else return find(mid+1,r,ch[x][1],ch[y][1],k-(record[ch[y][0]]-record[ch[x][0]]));&#125;void print2(int p1,int p2)&#123; if(p1==0&amp;&amp;p2==0) return; printf(\"%d(\",record[p2]-record[p1]); print2(ch[p1][0],ch[p2][0]); printf(\",\"); print2(ch[p1][1],ch[p2][1]); printf(\")\");&#125;void print(int p)&#123; if(p==0) return; printf(\"%d:%d(\",p,record[p]); print(ch[p][0]); printf(\",\"); print(ch[p][1]); printf(\")\");&#125;int main()&#123; scanf(\"%d%d\",&amp;N,&amp;M); for(int i=1;i&lt;=N;i++) scanf(\"%d\",d+i); memcpy(a,d,sizeof(a)); sort(a+1,a+N+1); m=unique(a+1,a+N+1)-a-1; for(int i=1,l,r,mid;i&lt;=N;i++)&#123; l=1; r=m; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(a[mid]&lt;d[i]) l=mid+1; else if(a[mid]&gt;d[i]) r=mid-1; else if(a[mid]==d[i]) break; &#125; d[i]=mid; &#125; root[0]=ch[0][0]=ch[0][1]=0; for(int i=1;i&lt;=N;i++)&#123; root[i]=++nodenum; add(1,m,root[i-1],root[i],d[i]);// print(root[i]);// printf(\"\\n\"); &#125; for(int i=1,x,y,k;i&lt;=M;i++)&#123; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;k);// print2(root[x-1],root[y]); printf(\"%d\\n\",a[find(1,m,root[x-1],root[y],k)]); &#125; return 0;&#125; 把它改成区间线段树，有可以AC两道紫题: P3919 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int Array_Limit=1000005;int N,M,a[Array_Limit&lt;&lt;5],root[Array_Limit&lt;&lt;5],record[Array_Limit&lt;&lt;5],ch[Array_Limit&lt;&lt;5][2],nodenum;void build(int l,int r,int p)&#123; if(l==r)&#123; record[p]=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,ch[p][0]=++nodenum); build(mid+1,r,ch[p][1]=++nodenum); record[p]=max(record[ch[p][0]],record[ch[p][1]]);&#125;void change(int l,int r,int from,int to,int k,int data)&#123; if(l==r)&#123; record[to]=data; return; &#125; int mid=(l+r)&gt;&gt;1; if(k&lt;=mid)&#123; ch[to][0]=++nodenum; ch[to][1]=ch[from][1]; change(l,mid,ch[from][0],ch[to][0],k,data); &#125; else&#123; ch[to][1]=++nodenum; ch[to][0]=ch[from][0]; change(mid+1,r,ch[from][1],ch[to][1],k,data); &#125; record[to]=max(record[ch[to][0]],record[ch[to][1]]);&#125;int find(int l,int r,int v,int k)&#123; if(l==r) return record[v]; int mid=(l+r)&gt;&gt;1; if(k&lt;=mid) return find(l,mid,ch[v][0],k); else return find(mid+1,r,ch[v][1],k);&#125;void print(int p)&#123; if(p==0) return; printf(\"%d:%d(\",p,record[p]); print(ch[p][0]); printf(\",\"); print(ch[p][1]); printf(\")\");&#125;int main()&#123; scanf(\"%d%d\",&amp;N,&amp;M); for(int i=1;i&lt;=N;i++) scanf(\"%d\",a+i); build(1,N,root[0]=++nodenum); for(int i=1,v,op,loc,data;i&lt;=M;i++)&#123; scanf(\"%d%d%d\",&amp;v,&amp;op,&amp;loc); if(op==1)&#123; scanf(\"%d\",&amp;data); change(1,N,root[v],root[i]=++nodenum,loc,data); &#125; else printf(\"%d\\n\",find(1,N,root[i]=root[v],loc)); &#125; return 0;&#125; P3402 tips: 启发式合并，讲并查集时在讲 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;time.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;using namespace std;const int Array_Limit=200005;int N,M,a[Array_Limit&lt;&lt;5],root[Array_Limit&lt;&lt;5],ch[Array_Limit&lt;&lt;5][2],nodenum;struct node&#123; int fa,dep;&#125;;node record[Array_Limit&lt;&lt;5];void build(int l,int r,int p)&#123; if(l==r)&#123; record[p].fa=a[l]; record[p].dep=1; return; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,ch[p][0]=++nodenum); build(mid+1,r,ch[p][1]=++nodenum); record[p].fa=max(record[ch[p][0]].fa,record[ch[p][1]].fa); record[p].dep=max(record[ch[p][0]].dep,record[ch[p][1]].dep);&#125;void change(int l,int r,int from,int to,int k,node data)&#123; if(l==r)&#123; record[to].fa=data.fa; record[to].dep=max(record[to].dep,1); return; &#125; int mid=(l+r)&gt;&gt;1; if(k&lt;=mid)&#123; ch[to][0]=++nodenum; ch[to][1]=ch[from][1]; change(l,mid,ch[from][0],ch[to][0],k,data); &#125; else&#123; ch[to][1]=++nodenum; ch[to][0]=ch[from][0]; change(mid+1,r,ch[from][1],ch[to][1],k,data); &#125; record[to].fa=max(record[ch[to][0]].fa,record[ch[to][1]].fa); record[to].dep=max(record[ch[to][0]].dep,record[ch[to][1]].dep);&#125;node find(int l,int r,int v,int k)&#123; if(l==r) return record[v]; int mid=(l+r)&gt;&gt;1; if(k&lt;=mid) return find(l,mid,ch[v][0],k); else return find(mid+1,r,ch[v][1],k);&#125;void print(int p)&#123; if(p==0) return; printf(\"%d:%d(\",p,record[p].fa); print(ch[p][0]); printf(\",\"); print(ch[p][1]); printf(\")\");&#125;int main()&#123; srand(time(NULL)); scanf(\"%d%d\",&amp;N,&amp;M); for(int i=1;i&lt;=N;i++) a[i]=i; build(1,N,root[0]=++nodenum); node a,b; for(int i=1,op;i&lt;=M;i++)&#123; scanf(\"%d\",&amp;op); if(op==1)&#123; scanf(\"%d%d\",&amp;a.fa,&amp;b.fa); while(a.fa!=find(1,N,root[i-1],a.fa).fa) a=find(1,N,root[i-1],a.fa); while(b.fa!=find(1,N,root[i-1],b.fa).fa) b=find(1,N,root[i-1],b.fa); if(a.dep&lt;b.dep)&#123; a.dep=max(a.dep-1,b.dep)+1; change(1,N,root[i-1],root[i]=++nodenum,b.fa,a); &#125; else&#123; b.dep=max(a.dep,b.dep-1)+1; change(1,N,root[i-1],root[i]=++nodenum,a.fa,b); &#125; &#125; else if(op==2)&#123; int a; scanf(\"%d\",&amp;a); root[i]=root[a]; &#125; else&#123; scanf(\"%d%d\",&amp;a.fa,&amp;b.fa); root[i]=root[i-1]; while(a.fa!=find(1,N,root[i],a.fa).fa) a=find(1,N,root[i],a.fa); while(b.fa!=find(1,N,root[i],b.fa).fa) b=find(1,N,root[i],b.fa); printf(\"%d\\n\",(a.fa==b.fa)?1:0); &#125; &#125; return 0;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"漫步数据结构1：线段树1","slug":"漫步数据结构1：线段树1","date":"2019-03-23T07:33:00.000Z","updated":"2019-04-01T09:56:36.199Z","comments":true,"path":"2019/03/23/漫步数据结构1：线段树1/","link":"","permalink":"http://yoursite.com/2019/03/23/漫步数据结构1：线段树1/","excerpt":"","text":"线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 By 百度百科 线段树一般分成两种：区间线段树和权值线段树 By 某大佬学长 1. 区间线段树区间线段树是一棵均衡二叉树，每个节点要么是叶子节点，要么有两个儿子,叶子节点维护元素信息，其他节点维护区间信息。一般情况下，线段树用堆式存储，除非…算了，不剧透了。先画个图： 图中我们发现，如果一个线段树非叶子节点表示$[l,r]$，定义$mid=\\left\\lfloor\\frac{l+r}{2}\\right\\rfloor$，那么它的左儿子表示的区间是$[l,mid]$，右儿子表示的区间是$[mid+1,r]$。 接下来要开始讲具体操作了，我们以维护区间和为例，但在代码中会维护区间和、区间$max$和区间$min$。 1.0 建树自上向下遍历到每个点，在自下向上维护信息，每个点都只被访问一次，所以是$O(n)$的。 1.1 单点修改，区间查询单点修改应该是最简单的操作了，只要自上往下找到目标点，然后自下往上修改区间信息就可以了，复杂度自然就和树高同级，是$O(nlgn)$。举个修改4号节点的例子： 查询的时候只需要分治，如果要查询的区间完全覆盖了当前节点所表示的区间时，直接返回 1.2 区间修改，单点查询现在我们需要引入$lazy_tag$的概念，$lazy_tag_x$表示$x$号节点表示的区间需要加$lazy_tag_x$，且$x$号节点还未进行过这次修改。 举个例子： 1.3 区间修改，区间查询其实只需要把1.1的查询操作和1.2的修改操作合起来就好了。 我猜已经可以直接上代码了，题意详见P3372： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt;#define min(x,y) ((x&lt;y)?x:y)#define max(x,y) ((x&gt;y)?x:y)#define rc ((p&lt;&lt;1)|1)#define lc (p&lt;&lt;1)#define mid ((l+r)&gt;&gt;1)long long n,m,a[100005],sum[400005],minn[400005],maxx[400005],addtag[400005],multag[400005];inline void down(long long p,long long l,long long r)&#123; sum[p]+=addtag[p]*(r-l+1); minn[p]+=addtag[p]; maxx[p]+=addtag[p]; if(r&gt;l)&#123; addtag[lc]+=addtag[p]; addtag[rc]+=addtag[p]; &#125; addtag[p]=0;&#125;inline void up(long long p,long long l,long long r)&#123; down(lc,l,mid); down(rc,mid+1,r); sum[p]=sum[lc]+sum[rc]; minn[p]=min(minn[lc],minn[rc]); maxx[p]=max(maxx[lc],maxx[rc]);&#125;void build(long long p,long long l,long long r)&#123; addtag[p]=0; multag[p]=1; if(l==r)&#123; sum[p]=a[l]; minn[p]=a[l]; maxx[p]=a[l]; return; &#125; build(lc,l,mid); build(rc,mid+1,r); up(p,l,r);&#125;long long find_sum(long long p,long long l,long long r,long long x,long long y)&#123; down(p,l,r); if(l==x&amp;&amp;r==y) return sum[p]; if(y&lt;=mid) return find_sum(lc,l,mid,x,y); else if(x&gt;mid) return find_sum(rc,mid+1,r,x,y); else return find_sum(lc,l,mid,x,mid)+find_sum(rc,mid+1,r,mid+1,y); up(p,l,r);&#125;void rangeadd(long long p,long long l,long long r,long long x,long long y,long long d)&#123; if(l==x&amp;&amp;r==y)&#123; addtag[p]+=d; return; &#125; sum[p]+=d*(y-x+1); minn[p]+=d; maxx[p]+=d; if(y&lt;=mid) rangeadd(lc,l,mid,x,y,d); else if(x&gt;mid) rangeadd(rc,mid+1,r,x,y,d); else&#123; rangeadd(lc,l,mid,x,mid,d); rangeadd(rc,mid+1,r,mid+1,y,d); &#125;&#125;int main()&#123; scanf(\"%lld%lld\",&amp;n,&amp;m); for(long long i=1;i&lt;=n;i++) scanf(\"%lld\",a+i); build(1,1,n); while(m--)&#123; long long op,x,y; scanf(\"%lld%lld%lld\",&amp;op,&amp;x,&amp;y); if(op==2) printf(\"%lld\\n\",find_sum(1,1,n,x,y)); else&#123; long long d; scanf(\"%lld\",&amp;d); rangeadd(1,1,n,x,y,d); &#125; &#125; return 0;&#125; 1.4 1.3++聪明的读者一定已经想到线段树理应支持P3373的操作——区间乘法。其实这很简单，只要分别记录乘法$lazy_tag$和加法$lazy_tag$即可，我猜已经可以直接上代码了（由于常数限制，只维护区间和）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;stdio.h&gt;int n,m,MOD,a[400005],sum[1600005],addtag[1600005],multag[1600005];inline void down(int p,int l,int r)&#123; sum[p]=((long long)sum[p]*multag[p]+(long long)addtag[p]*(r-l+1))%MOD; if(l&lt;r)&#123; addtag[(p&lt;&lt;1)]=((long long)addtag[(p&lt;&lt;1)]*multag[p]+addtag[p])%MOD; addtag[((p&lt;&lt;1)|1)]=((long long)addtag[((p&lt;&lt;1)|1)]*multag[p]+addtag[p])%MOD; multag[(p&lt;&lt;1)]=(long long)multag[(p&lt;&lt;1)]*multag[p]%MOD; multag[((p&lt;&lt;1)|1)]=(long long)multag[((p&lt;&lt;1)|1)]*multag[p]%MOD; &#125; addtag[p]=0; multag[p]=1;&#125;inline void up(int p,int l,int r)&#123; down((p&lt;&lt;1),l,((l+r)&gt;&gt;1)); down(((p&lt;&lt;1)|1),((l+r)&gt;&gt;1)+1,r); if(l&lt;r)&#123; sum[p]=(sum[(p&lt;&lt;1)]+sum[((p&lt;&lt;1)|1)])%MOD; &#125;&#125;void build(int p,int l,int r)&#123; addtag[p]=0; multag[p]=1; if(l==r)&#123; sum[p]=a[l]; return; &#125; build((p&lt;&lt;1),l,((l+r)&gt;&gt;1)); build(((p&lt;&lt;1)|1),((l+r)&gt;&gt;1)+1,r); up(p,l,r);&#125;int find_sum(int p,int l,int r,int x,int y)&#123; down(p,l,r); up(p,l,r); if(l==x&amp;&amp;r==y) return sum[p]; if(y&lt;=((l+r)&gt;&gt;1)) return find_sum((p&lt;&lt;1),l,((l+r)&gt;&gt;1),x,y); else if(x&gt;((l+r)&gt;&gt;1)) return find_sum(((p&lt;&lt;1)|1),((l+r)&gt;&gt;1)+1,r,x,y); else return find_sum((p&lt;&lt;1),l,((l+r)&gt;&gt;1),x,((l+r)&gt;&gt;1))+find_sum(((p&lt;&lt;1)|1),((l+r)&gt;&gt;1)+1,r,((l+r)&gt;&gt;1)+1,y);&#125;void rangeadd(int p,int l,int r,int x,int y,int d)&#123; down(p,l,r); up(p,l,r); if(l==x&amp;&amp;r==y)&#123; addtag[p]+=d; down(p,l,r); return; &#125; if(y&lt;=((l+r)&gt;&gt;1)) rangeadd((p&lt;&lt;1),l,((l+r)&gt;&gt;1),x,y,d); else if(x&gt;((l+r)&gt;&gt;1)) rangeadd(((p&lt;&lt;1)|1),((l+r)&gt;&gt;1)+1,r,x,y,d); else&#123; rangeadd((p&lt;&lt;1),l,((l+r)&gt;&gt;1),x,((l+r)&gt;&gt;1),d); rangeadd(((p&lt;&lt;1)|1),((l+r)&gt;&gt;1)+1,r,((l+r)&gt;&gt;1)+1,y,d); &#125; up(p,l,r);&#125;void rangemul(int p,int l,int r,int x,int y,int d)&#123; down(p,l,r); up(p,l,r); if(l==x&amp;&amp;r==y)&#123; multag[p]=(long long)multag[p]*d; addtag[p]=(long long)addtag[p]*d; down(p,l,r); return; &#125; if(y&lt;=((l+r)&gt;&gt;1)) rangemul((p&lt;&lt;1),l,((l+r)&gt;&gt;1),x,y,d); else if(x&gt;((l+r)&gt;&gt;1)) rangemul(((p&lt;&lt;1)|1),((l+r)&gt;&gt;1)+1,r,x,y,d); else&#123; rangemul((p&lt;&lt;1),l,((l+r)&gt;&gt;1),x,((l+r)&gt;&gt;1),d); rangemul(((p&lt;&lt;1)|1),((l+r)&gt;&gt;1)+1,r,((l+r)&gt;&gt;1)+1,y,d); &#125; up(p,l,r);&#125;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;MOD); for(register int i=1;i&lt;=n;i++) scanf(\"%d\",a+i); build(1,1,n); while(m--)&#123; int op,x,y; scanf(\"%d%d%d\",&amp;op,&amp;x,&amp;y); if(op==3) printf(\"%d\\n\",find_sum(1,1,n,x,y)%MOD); else&#123; int d; scanf(\"%d\",&amp;d); if(op==2) rangeadd(1,1,n,x,y,d); else rangemul(1,1,n,x,y,d); &#125; &#125; return 0;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"浅析卷积","slug":"浅析卷积","date":"2019-03-19T10:01:02.000Z","updated":"2019-04-01T09:53:26.784Z","comments":true,"path":"2019/03/19/浅析卷积/","link":"","permalink":"http://yoursite.com/2019/03/19/浅析卷积/","excerpt":"","text":"0. 写在前面从粗斜体到分界线中的内容可以跳过。 本文中一些算法的简历： 简写 全称 中文 搞笑 FWT Fast Walsh Transformation 快速沃尔什变换 Fast Wonderful TLE FFT Fast Fourier Transformation 快速傅里叶变换 Fast Fantastic TLE NTT Number Theory Transformation 快速数论变换 Natural Talented TLE 1. 卷积的定义c_i=\\sum_{j*k=i}{a_j\\times b_k}$ c $ 称为 $ a,b $ 的卷积，当 $ * $ 指不同的运算符时， $ c $ 有不同的求法，现在分类讨论。 2. 当 $*$ 指 $max/min$可以通过简单的前/后缀和计算，以下是 $max$ 卷积的代码：123456789101112131415161718192021#include&lt;stdio.h&gt;int N,a[1000005],b[1000005],c[1000005],A[1000005],B[1000005],C[1000005];int main()&#123; scanf(\"%d\",&amp;N); for(int i=1;i&lt;=N;i++) scanf(\"%d\",a+i); for(int i=1;i&lt;=N;i++) scanf(\"%d\",b+i); for(int i=1;i&lt;=N;i++)&#123; A[i]=a[i]+A[i-1]; B[i]=b[i]+A[i-1]; &#125; for(int i=1;i&lt;=N;i++) C[i]=A[i]*B[i]; for(int i=N;i&gt;=1;i--) c[i]=C[i]-C[i-1]; for(int i=1;i&lt;=N-1;i++) printf(\"%d \",c[i]); printf(\"%d\\n\",c[N]); return 0;&#125; $min$卷积与之类似。 为什么它是正确的？ 讨论 $max$ 卷积 c_i=\\sum_{max(j,k)=i}{a_j\\times b_k}即 c_i=a_i\\times b_i+\\sum_{j=1}^{i-1}{(a_j\\times b_i+b_j\\times a_i)}程序中 A_i=\\sum_{j=1}^{i}{a_j}\\text{ }\\text{ }\\text{ }\\text{ }B_i=\\sum_{j=1}^{i}{b_j}所以 C_i=\\sum_{j=1}^{i}{\\sum_{k=1}^{i}{a_j\\times b_k}}易得 c_i=C_i-C_{i-1}=\\sum_{j=1}^{i}{(a_j\\times b_i)}+\\sum_{j=1}^{i-1}{(a_i\\times b_j)}与理论答案相符 由此我们可以总结出一点经验，求卷积的流程往往是这样： 用某种变换将$a_i,b_i$变成$A_i,B_i$ $C_i=A_i\\times B_i$ 用其逆变换将$C_i$变成$c_i$得到答案 3. 当 $*$ 指 $\\vee/\\wedge$在这篇文章中，如果涉及到带 $lg_N$ 复杂度的卷积变换， $N=2^k(k\\in\\mathbb{N})$ 。实际实现时在高位补 $0$ 3.1 用向量表示数一个$k$位二进制数可以表示成一个$k$维向量。例如当$k=3$时： 数值 向量表示 数值 向量表示 0 $\\left \\{ 0,0,0 \\right \\}$ 4 $\\left \\{ 1,0,0 \\right \\}$ 1 $\\left \\{ 0,0,1 \\right \\}$ 5 $\\left \\{ 1,0,1 \\right \\}$ 2 $\\left \\{ 0,1,0 \\right \\}$ 6 $\\left \\{ 1,1,0 \\right \\}$ 3 $\\left \\{ 0,1,1 \\right \\}$ 7 $\\left \\{ 1,1,1 \\right \\}$ 3.2 $\\vee$的实质我们把用向量表示的数字$\\vee$,例如 3\\vee 6=\\left \\{ 0,1,1 \\right \\}\\vee\\left \\{ 1,1,0 \\right \\}=\\left \\{ 1,1,1 \\right \\}=7由此可知$\\vee$的本质是按位 $max$ ，所以 $\\vee$ 卷积的变换就是按位前缀和。它的逆变换其实是一个脑筋急转弯，只要把循环倒过来，把$+=$改成$-=$就可以了。代码如下：12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;int n,k,N,a[100005],b[100005],c[100005];int main()&#123; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++) scanf(\"%d\",a+i); for(int i=0;i&lt;n;i++) scanf(\"%d\",b+i); for(N=1;N&lt;n;N&lt;&lt;=1,k++); for(int i=0;i&lt;k;i++) for(int j=0;j&lt;N;j++) if((j&amp;(1&lt;&lt;i))==0) a[j+(1&lt;&lt;i)]+=a[j]; for(int i=0;i&lt;k;i++) for(int j=0;j&lt;N;j++) if((j&amp;(1&lt;&lt;i))==0) b[j+(1&lt;&lt;i)]+=b[j]; for(int i=0;i&lt;N;i++) c[i]=a[i]*b[i]; for(int i=k-1;i&gt;=0;i--) for(int j=N-1;j&gt;=0;j--) if((j&amp;(1&lt;&lt;i))==0) c[j+(1&lt;&lt;i)]-=c[j]; for(int i=0;i&lt;=N-2;i++) printf(\"%d \",c[i]); printf(\"%d\\n\",c[N-1]); return 0;&#125; $\\wedge$卷积与之类似。 4. 当$*$指$\\bigoplus$4.1 千里之行，始于足下：N=2有小学知识可知： \\Rightarrow \\Rightarrow 我们将$a_i,b_i$带入 C_0=A_0\\times B_0=(a_0+a_1)\\times (b_0+b_1)=a_0\\times b_0+a_0\\times b_1+a_1\\times b_0+a_1\\times b_1C_1=A_1\\times B_1=(a_0-a_1)\\times (b_0-b_1)=a_0\\times b_0-a_0\\times b_1-a_1\\times b_0+a_1\\times b_1c_0=\\frac{C_0+C_1}{2}=a_0\\times b_0+a_1\\times b_1c_1=\\frac{C_0-C_1}{2}=a_0\\times b_1+a_1\\times b_0听说是正确的，于是拓展到高维 A_i=\\sum_{j=0}^{N}{(-1)^{bitcount(i\\wedge j)\\times a_j}}4.2 一句不是废话的废话虽然我们已经发现了正解，我们还是从向量的角度看一下。比如 3\\bigoplus 6=\\left \\{ 0,1,1 \\right \\}\\bigoplus\\left \\{ 1,1,0 \\right \\}=\\left \\{ 1,0,1 \\right \\}=5再写一遍 3\\bigoplus 6=\\left \\{ 0,1,1 \\right \\}\\bigoplus\\left \\{ 1,1,0 \\right \\}=\\left \\{ (0+1)\\%2,(1+1)\\%2,(1+0)\\%2 \\right \\}=\\left \\{ 1,0,1 \\right \\}=5发现$\\bigoplus$其实是二进制无进位加法。 4.3 具体实现$\\bigoplus$卷积的变换代码与$\\vee/\\wedge$卷积的代码略有不同，但$\\vee/\\wedge$卷积的代码也可以写成这种形式，具体题意见 洛谷P4717【模板】快速沃尔什变换 。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;stdio.h&gt;const int p=998244353;inline int power(int a,int k)&#123; int ans=1; for(;k;a=1LL*a*a%p,k&gt;&gt;=1) if(k&amp;1) ans=1LL*ans*a%p; return ans;&#125;int len,N,a[4][300005],b[4][300005];void FWT(int* a,int op,int flag)&#123; int x,y; if(op==3&amp;&amp;flag==-1)&#123; for(int i=N&gt;&gt;1;i&gt;0;i&gt;&gt;=1) for(int j=0;j&lt;N;j+=i&lt;&lt;1) for(int k=0;k&lt;i;k++)&#123; x=a[j+k]; y=a[i+j+k]; a[j+k]=1LL*(x+y)*power(2,p-2)%p; a[i+j+k]=(1LL*(x-y)*power(2,p-2)%p+p)%p; &#125; return; &#125; for(int i=1;i&lt;N;i&lt;&lt;=1) for(int j=0;j&lt;N;j+=i&lt;&lt;1) for(int k=0;k&lt;i;k++)&#123; x=a[j+k]; y=a[i+j+k]; if(op==1)&#123; if(flag==1)&#123; a[j+k]=x; a[i+j+k]=(x+y)%p; &#125; else&#123; a[j+k]=x; a[i+j+k]=((y-x)%p+p)%p; &#125; &#125; if(op==2)&#123; if(flag==1)&#123; a[j+k]=(x+y)%p; a[i+j+k]=y; &#125; else&#123; a[j+k]=((x-y)%p+p)%p; a[i+j+k]=y; &#125; &#125; if(op==3)&#123; a[j+k]=(x+y)%p; a[i+j+k]=((x-y)%p+p)%p; &#125; &#125;&#125;int main()&#123; scanf(\"%d\",&amp;len); N=power(2,len); for(int i=0;i&lt;N;i++)&#123; scanf(\"%d\",a[1]+i); a[3][i]=a[2][i]=a[1][i]; &#125; for(int i=0;i&lt;N;i++)&#123; scanf(\"%d\",b[1]+i); b[3][i]=b[2][i]=b[1][i]; &#125; for(int j=1;j&lt;=3;j++)&#123; FWT(a[j],j,1); FWT(b[j],j,1); &#125; for(int i=0;i&lt;N;i++) for(int j=1;j&lt;=3;j++) a[j][i]=1LL*a[j][i]*b[j][i]%p; for(int j=1;j&lt;=3;j++) FWT(a[j],j,-1); for(int j=1;j&lt;=3;j++)&#123; for(int i=0;i&lt;N-1;i++) printf(\"%d \",a[j][i]); printf(\"%d\\n\",a[j][N-1]); &#125; return 0;&#125; 5. 当$*$指$+$公式恐惧症患者请果断按下Ctrl+W以发起正当防卫 5.1 求多项式乘法的新方法定义$N$次多项式$g,h$，我们可以选取$x_{0…2\\times N}$带入$g,h$得到$G_{0…2\\times N},H_{0…2\\times N}$,将G和H逐位相乘得到$F$，最后将$F$消元得到$f$,$f=g\\times h$。 不幸的是，带入多项式需要 $O(n^2)$ 。What’s worse,高斯消元需要 $O(n^3)$ 。 5.2 选择带入的数显然，瓶颈在带入的数的选择上。那我们需要带入怎样的数带入呢？ 5.2.1 复数我们知道， $x^2=-1$ 无实数解，但我们定义 $i^2=-1$ 。 复数是所有能够写成 $a+i\\times b(a,b\\in \\mathbb{R})$ 的数的集合，该集合记作 $\\mathbb{C}$。 5.2.2 复数的性质 对于任意整数 $n\\geqslant0,k\\geqslant0,d\\geqslant0$ 有 \\omega_{N}^{k}=\\omega_{Nd}^{kd} 对于任意整数 $n\\geqslant0,k\\geqslant0$ 有 \\omega_{N}^{k}=\\omega_{2N}^{2k} 对于任意整数 $n\\geqslant0$ 有 \\omega_{N}^{\\frac{N}{2}}=-1 对于任意整数 $n\\geqslant0,i\\geqslant0,j\\geqslant0$ 有 \\omega_{N}^{i+j}=\\omega_{N}^{i}\\times\\omega_{N}^{j} 对于任意整数 $n\\geqslant0,i\\geqslant0,j\\geqslant0$ 有 \\omega_{N}^{ij}=(\\omega_{N}^{i})^j5.3 开始带入!我们定义将$&lt;\\omega_N^0,\\omega_N^1, … ,\\omega_N^{N-1}&gt;$带入$$的结果设为$$。 根据定义得 A_i=\\sum_{j=0}^{N-1}a_j\\times(\\omega_N^i)^j由性质5得 A_i=\\sum_{j=0}^{N-1}a_j\\times\\omega_N^{ij}我们把$i$的定义域从 $[0,N-1]$ 变成 $[0,\\frac{N}{2}-1]$ A_i=\\sum_{j=0}^{N-1}a_j\\times\\omega_N^{ij}A_{i+\\frac{N}{2}}=\\sum_{j=0}^{N-1}a_j\\times\\omega_N^{(i+\\frac{N}{2})\\times j}奇偶分类 A_i=\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j}\\times\\omega_N^{2ij}+\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j+1}\\times\\omega_N^{i(2j+1)}=\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j}\\times\\omega_{\\frac{N}{2}}^{ij}+\\omega_N^i\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j+1}\\omega_{\\frac{N}{2}}^{ij}A_{i+\\frac{N}{2}}=\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j}\\times\\omega_N^{2(i+\\frac{N}{2})j}+\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j+1}\\times\\omega_N^{(i+\\frac{N}{2})(2j+1)}=\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j}\\times\\omega_{\\frac{N}{2}}^{ij}+\\omega_N^{i+\\frac{N}{2}}\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j+1}\\omega_{\\frac{N}{2}}^{ij}=\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j}\\times\\omega_{\\frac{N}{2}}^{ij}-\\omega_N^i\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j+1}\\omega_{\\frac{N}{2}}^{ij}于是我们惊喜地发现，这可以分治做。 为什么需要奇偶分类呢？也许这就是傅里叶的伟大之处吧。 5.4 逆变换那么FFT的逆变换怎么写呢？ 令人惊讶的是，恰有 a_i=\\frac{\\sum_{j=0}^{N-1}A_j\\times\\omega_N^{-ij}}{N} 为什么它是正确的？ a_i=\\frac{\\sum_{j=0}^{N-1}A_j\\times\\omega_N^{-ij}}{N}=\\frac{\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1}a_k\\times\\omega_N^{jk}\\times\\omega_N^{-ij}}{N}=\\frac{\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1}a_k\\times\\omega_N^{j(k-i)}}{N}=\\frac{\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1}a_k[i==k]}{N}=\\frac{N\\times a_i}{N}=a_i 5.5 蝴蝶变换我们将$N=8$的分治情况手动模拟一下，可以得到: 区间大小 $id_0$ $id_1$ $id_2$ $id_3$ $id_4$ $id_5$ $id_6$ $id_7$ 8 0 1 2 3 4 5 6 7 4 0 2 4 6 1 3 5 7 2 0 4 2 6 1 5 3 7 1 0 4 2 6 1 5 3 7 把这个表格用二进制描述 区间大小 $id_0$ $id_1$ $id_2$ $id_3$ $id_4$ $id_5$ $id_6$ $id_7$ 8 000 001 010 011 100 101 110 111 4 000 010 100 110 001 011 101 111 2 000 100 010 110 001 101 011 111 1 000 100 010 110 001 101 011 111 我们发现表格的第一行和最后一行二进制是反转的，这样我们就发现了$FFT$的非递归写法，代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;math.h&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const double pi=acos(-1.0);int n,m,res=0,N=1,len,revers[2097160];long long ans[2097160];int i,j,k,l;struct node&#123; double x,y; node(double x=0,double y=0):x(x),y(y)&#123;&#125; node operator*(const node &amp;b)&#123; return node(x*b.x-y*b.y,x*b.y+y*b.x); &#125; node operator+(const node &amp;b)&#123; return node(x+b.x,y+b.y); &#125; node operator-(const node &amp;b)&#123; return node(x-b.x,y-b.y); &#125;&#125;a[2097160],b[2097160],T,t,x,y;void FFT(node *a,double flag)&#123; for(i=0;i&lt;N;i++) if(i&lt;revers[i]) swap(a[i],a[revers[i]]); for(j=1;j&lt;N;j&lt;&lt;=1)&#123; T=node(cos(pi/j),flag*sin(pi/j)); for(k=0;k&lt;N;k+=(j&lt;&lt;1))&#123; t=node(1,0); for(l=0;l&lt;j;l++,t=t*T)&#123; x=a[k+l],y=t*a[k+j+l]; a[k+l]=x+y; a[k+j+l]=x-y; &#125; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); n++; m++; for(i=0;i&lt;n;i++) scanf(\"%lf\",&amp;a[i].x); for(i=0;i&lt;m;i++) scanf(\"%lf\",&amp;b[i].x); for(;N&lt;max(n,m)&lt;&lt;1;N&lt;&lt;=1,len++); for(i=0;i&lt;=N;i++) revers[i]=(revers[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(len-1)); FFT(a,1); FFT(b,1); for(i=0;i&lt;=N;i++) a[i]=a[i]*b[i]; FFT(a,-1); for(i=0;i&lt;=N;i++) ans[i]+=(long long)(a[i].x/N+0.5); for(;!ans[N]&amp;&amp;N;N--); N++; for(i=0;i&lt;n+m-2;i++) printf(\"%lld \",ans[i]); printf(\"%lld\\n\",ans[n+m-2]); return 0;&#125; 5.6 精度问题把上面的代码加入模操作后提交到 洛谷P4245【模板】任意模数NTT 里去发现光荣WA。 然后就发现FFT有精度问题，那么如何避免呢？ 5.6.1 原根如果$g$的$0$ ~ $\\phi(p)-1$在模$p$意义下正好遍历了$1$ ~ $p-1$中与$p$互质的$\\phi(p)$个数，那么称$g$为$p$的原根。 当p为质数时，我们发现如果用$g^\\frac{p-1}{N}$代替单位复根（记为$g_N$）,它满足单位复根的所有性质: 对于任意整数 $n\\geqslant0,k\\geqslant0,d\\geqslant0$ 有 g_{N}^{k}=g_{Nd}^{kd} 对于任意整数 $n\\geqslant0,k\\geqslant0$ 有 g_{N}^{k}=g_{2N}^{2k} 对于任意整数 $n\\geqslant0$ 有 g_{N}^{\\frac{N}{2}}=-1 对于任意整数 $n\\geqslant0,i\\geqslant0,j\\geqslant0$ 有 g_{N}^{i+j}=g_{N}^{i}\\times g_{N}^{j} 对于任意整数 $n\\geqslant0,i\\geqslant0,j\\geqslant0$ 有 g_{N}^{ij}=(g_{N}^{i})^j5.6.2 能选的质数一般情况下有三个质数可选: $469762049=7\\times 2^{26}+1$ $998244353=119\\times 2^{23}+1$ $1004535809=749\\times 2^{21}+1$ 当$p$取上面几个质数时，$g=3$，$p-1$中有很多$2$的因子，FFT中$N$又都是$2$的次幂，所以上面三个质数一定要记下来。 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const long long p=998244353,g=3,invg=332748118;int n,m,res=0,N=1,len,revers[2097160];long long ans[2097160],a[2097160],b[2097160],T,t,x,y;int i,j,k,l;inline long long power(long long a,long long k,long long p)&#123; long long ans=1,t=a; for(;k;k&gt;&gt;=1,t=t*t%p) if(k&amp;1) ans=ans*t%p; return ans;&#125;void NTT(long long *a,long long flag)&#123; for(i=0;i&lt;N;i++) if(i&lt;revers[i]) swap(a[i],a[revers[i]]); for(j=1;j&lt;N;j&lt;&lt;=1)&#123; T=power(flag==1?g:invg,(p-1)/j/2,p); for(k=0;k&lt;N;k+=(j&lt;&lt;1))&#123; t=1; for(l=0;l&lt;j;l++,t=t*T%p)&#123; x=a[k+l],y=t*a[k+j+l]%p; a[k+l]=(x+y)%p; a[k+j+l]=((x-y)%p+p)%p; &#125; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); n++; m++; for(i=0;i&lt;n;i++)&#123; scanf(\"%lld\",a+i); a[i]=a[i]%p; &#125; for(i=0;i&lt;m;i++)&#123; scanf(\"%lld\",b+i); b[i]=b[i]%p; &#125; for(;N&lt;max(n,m)&lt;&lt;1;N&lt;&lt;=1,len++); for(i=0;i&lt;=N;i++) revers[i]=(revers[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(len-1)); NTT(a,1); NTT(b,1); for(i=0;i&lt;=N;i++) a[i]=a[i]*b[i]%p; NTT(a,-1); for(i=0;i&lt;=N;i++) ans[i]=a[i]*power(N,p-2,p)%p; for(i=0;i&lt;n+m-2;i++) printf(\"%lld \",ans[i]); printf(\"%lld\\n\",ans[n+m-2]); return 0;&#125; 5.7 换个角度看$\\bigoplus$卷积我们再回忆一下4.2节的内容，我们在做$\\bigoplus$卷积时，其实可以做$lg_N$遍$FFT$，然后又因为$\\omega_2^0=1$，$\\omega_2^1=-1$，就可以得到4.1节的结论了。 5.8 FFT再拓展在洛谷上搜索FFT会发现还有一道 洛谷P4245【模板】任意模数NTT ，怎么lòng？我们定三个质数做模数，一般是5.6.2节中的三个，分别进行$NTT$，最后用$CRT$强制求出解，注意爆long long（对，你没看错，不是爆int），$CRT$时模的勤劳一点。 贴代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;cstdio&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;int mod;inline int power(int a,int k,int p)&#123; int ans; for(ans=1;k;k&gt;&gt;=1,a=1LL*a*a%p) if(k&amp;1) ans=1LL*ans*a%p; return ans;&#125;const int p[3]=&#123;469762049,998244353,1004535809&#125;,g=3;class longint&#123; private: int A,B,C; static longint reduce(const longint &amp;x)&#123; return longint(x.A+(x.A&gt;&gt;31&amp;p[0]),x.B+(x.B&gt;&gt;31&amp;p[1]),x.C+(x.C&gt;&gt;31&amp;p[2])); &#125; public: explicit longint()&#123;&#125; explicit longint(int x)&#123; A=B=C=x; &#125; explicit longint(int x,int y,int z)&#123; A=x; B=y; C=z; &#125; friend longint operator+(const longint &amp;lsh,const longint &amp;rsh)&#123; return reduce(longint(lsh.A+rsh.A-p[0],lsh.B+rsh.B-p[1],lsh.C+rsh.C-p[2])); &#125; friend longint operator-(const longint &amp;lsh,const longint &amp;rsh)&#123; return reduce(longint(lsh.A-rsh.A,lsh.B-rsh.B,lsh.C-rsh.C)); &#125; friend longint operator*(const longint &amp;lsh,const longint &amp;rsh)&#123; return longint(1LL*lsh.A*rsh.A%p[0],1LL*lsh.B*rsh.B%p[1],1LL*lsh.C*rsh.C%p[2]); &#125; int get()&#123; long long x=1LL*(B-A+p[1])%p[1]*power(p[0],p[1]-2,p[1])%p[1]*p[0]+A; return (1LL*(C-x%p[2]+p[2])%p[2]*power(1LL*p[0]*p[1]%p[2],p[2]-2,p[2])%p[2]*(1LL*p[0]*p[1]%mod)+x)%mod; &#125;&#125;;const int Array_Limit=1&lt;&lt;18;int N,len,revers[Array_Limit|5];longint exp[Array_Limit|5];void init(int n)&#123; len=-1; N=1; while(N&lt;n)&#123; N&lt;&lt;=1; len++; &#125; for(int i=1;i&lt;=N;i++) revers[i]=revers[i&gt;&gt;1]&gt;&gt;1|(i&amp;1)&lt;&lt;len; longint t(power(g,(p[0]-1)/N,p[0]),power(g,(p[1]-1)/N,p[1]),power(g,(p[2]-1)/N,p[2])); exp[0]=longint(1); for(longint *i=exp;i!=exp+N;i++) *(i+1)=*i*t;&#125;void NTT(longint *a,int flag)&#123; for(int i=1;i&lt;Array_Limit;i++) if(i&lt;revers[i]) swap(a[i],a[revers[i]]); for(int i=1;i&lt;N;i&lt;&lt;=1)&#123; int t=N/i&gt;&gt;1; for(int j=0;j&lt;N;j+=i&lt;&lt;1) for(int k=0;k&lt;i;k++)&#123; longint x=flag==1?exp[t*k]:exp[N-t*k],y=a[i+j+k]*x; x=a[j+k]; a[j+k]=x+y; a[i+j+k]=x-y; &#125; &#125; if(flag==-1)&#123; longint inv_N(power(N,p[0]-2,p[0]),power(N,p[1]-2,p[1]),power(N,p[2]-2,p[2])); for(longint *i=a;i!=a+N;i++) *i=(*i)*inv_N; &#125;&#125;int n,m;longint a[Array_Limit|5],b[Array_Limit|5];int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;mod); n++; m++; for(int i=0,x;i&lt;n;i++)&#123; scanf(\"%d\",&amp;x); a[i]=longint(x%mod); &#125; for(int i=0,x;i&lt;m;i++)&#123; scanf(\"%d\",&amp;x); b[i]=longint(x%mod); &#125; init(n+m); NTT(a,1); NTT(b,1); for(int i=0;i&lt;N;i++) a[i]=a[i]*b[i]; NTT(a,-1); for(int i=0;i&lt;n+m-2;i++) printf(\"%d \",a[i].get()); printf(\"%d\\n\",a[n+m-2].get()); return 0;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2019-03-19T09:34:40.448Z","updated":"2019-03-19T09:34:40.448Z","comments":true,"path":"2019/03/19/hello-world/","link":"","permalink":"http://yoursite.com/2019/03/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}